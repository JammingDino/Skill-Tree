import os
import requests
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageOps, ImageChops, ImageEnhance
from dotenv import load_dotenv
import random
import math
import re

# Load configuration
load_dotenv()
WEBHOOK_URL = os.getenv('DISCORD_WEBHOOK_URL')

# --- CONFIGURATION ---
MODRINTH_ID = os.getenv('MODRINTH_PROJECT_ID', 'dnC6tCcs')
CURSEFORGE_ID = os.getenv('CURSEFORGE_PROJECT_ID', '1397099')

VERSION = os.getenv('RELEASE_VERSION', 'v1.1.0')
MOD_NAME = "Skill Tree"
HYPE_LEVEL = 3

# Links
SOURCE_URL = "https://github.com/YourRepo/Source"
MODRINTH_URL = f"https://modrinth.com/mod/skill-tree-(fabric)"
CURSEFORGE_URL = f"https://www.curseforge.com/minecraft/mc-mods/skill-tree-fabric"

raw_body = os.getenv('RELEASE_BODY')

if not raw_body:
    # Try to read the file generated by the previous workflow step
    # We assume the script is running from scripts/release_generator/, so root is ../../
    note_path = "../../RELEASE_NOTES.md"
    if os.path.exists(note_path):
        with open(note_path, "r", encoding="utf-8") as f:
            raw_body = f.read()

if raw_body:
    RAW_COMMITS = [raw_body]
else:
    # Fallback for local testing
    RAW_COMMITS = [
        "feat(core): implemented dynamic versioning",
        "fix(gui): resolved texture alignment issues"
    ]

IMG_WIDTH = 1920
IMG_HEIGHT = 1080
PANEL_WIDTH = IMG_WIDTH // 2

# --- DATA SCRAPING ---

def fetch_stats():
    """Fetches live download counts."""
    print("Fetching live stats...")
    m_count = 0
    c_count = 0

    try:
        url = f"https://api.modrinth.com/v2/project/{MODRINTH_ID}"
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            m_count = int(response.json().get('downloads', 0))
    except Exception as e:
        print(f"Modrinth Error: {e}")

    try:
        url = f"https://api.cfwidget.com/{CURSEFORGE_ID}"
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            c_count = int(response.json().get('downloads', {}).get('total', 0))
    except Exception as e:
        print(f"CurseForge Error: {e}")

    if m_count == 0: m_count = 84000
    if c_count == 0: c_count = 110000

    return m_count, c_count

# --- TEXT PARSING & WRAPPING ENGINE ---

def parse_commits(raw_list):
    """
    Parses commit messages, preserving headers and scope information.
    Converts 'feat(scope): message' -> 'Scope: message'.
    """
    cleaned_features = []

    for raw in raw_list:
        # Split by newline to handle bullet points and headers separately
        lines = raw.split('\n')

        for line in lines:
            line = line.strip()
            if not line: continue

            # Remove bullet point markers for processing
            clean_text = line.lstrip("-*• ")

            # Intelligent Regex: formatting "type(scope): message"
            # Captures 'type', 'scope' (optional), and 'message'
            match = re.match(r'^(?:feat|fix|chore|refactor|style|docs|test)(?:\((.*?)\))?:\s*(.*)', clean_text, re.IGNORECASE)

            if match:
                scope = match.group(1)
                message = match.group(2)

                # If there is a scope, include it nicely (e.g. "Actions: Add complex...")
                if scope:
                    clean_text = f"{scope.capitalize()}: {message}"
                else:
                    clean_text = message

            # Handle smashed sentences (camelCase splits) just in case
            clean_text = re.sub(r'([a-z])([A-Z])', r'\1. \2', clean_text)

            # Capitalize first letter
            if clean_text:
                clean_text = clean_text[0].upper() + clean_text[1:]

            cleaned_features.append(clean_text)

    # Dedup preserving order
    seen = set()
    return [x for x in cleaned_features if not (x in seen or seen.add(x))]

def wrap_text(text, font, max_width, draw):
    """Breaks text into lines that fit max_width."""
    words = text.split()
    lines = []
    current_line = []

    for word in words:
        test_line = ' '.join(current_line + [word])
        bbox = draw.textbbox((0, 0), test_line, font=font)
        w = bbox[2] - bbox[0]

        if w <= max_width:
            current_line.append(word)
        else:
            if current_line:
                lines.append(' '.join(current_line))
                current_line = [word]
            else:
                lines.append(word)
                current_line = []

    if current_line:
        lines.append(' '.join(current_line))
    return lines

def fit_text_to_box(draw, text_items, max_width, max_height, start_font_size=55, min_font_size=20):
    """Iteratively fits text into the right panel."""
    current_size = start_font_size
    font_path = "assets/font.ttf"

    while current_size >= min_font_size:
        try:
            font = ImageFont.truetype(font_path, current_size)
        except:
            font = ImageFont.load_default()

        bbox = draw.textbbox((0, 0), "A", font=font)
        line_height = (bbox[3] - bbox[1]) + int(current_size * 0.4)

        total_h = 0
        wrapped_groups = []

        for item in text_items:
            lines = wrap_text(item, font, max_width, draw)
            wrapped_groups.append(lines)
            total_h += len(lines) * line_height
            total_h += int(line_height * 0.5) # Spacing between items

        if total_h <= max_height:
            return font, wrapped_groups, total_h, line_height

        current_size -= 2

    return font, wrapped_groups, total_h, line_height

# --- GRAPHICS HELPERS ---

def make_rounded_icon_with_glow(icon_path, size, radius):
    try:
        icon = Image.open(icon_path).convert("RGBA")
    except FileNotFoundError:
        print(f"WARNING: {icon_path} not found. Creating placeholder.")
        icon = Image.new('RGBA', (size, size), (50, 200, 100))

    icon = icon.resize((size, size), Image.Resampling.LANCZOS)
    mask = Image.new('L', (size, size), 0)
    ImageDraw.Draw(mask).rounded_rectangle([(0, 0), (size, size)], radius=radius, fill=255)

    clean_icon = Image.new('RGBA', (size, size), (0,0,0,0))
    clean_icon.paste(icon, (0, 0), mask=mask)

    glow_spread = 80
    canvas_size = size + glow_spread * 2
    glow_canvas = Image.new('RGBA', (canvas_size, canvas_size), (0,0,0,0))

    shadow_rect = [(glow_spread + 10, glow_spread + 10), (canvas_size - glow_spread - 10, canvas_size - glow_spread - 10)]
    ImageDraw.Draw(glow_canvas).rounded_rectangle(shadow_rect, radius=radius, fill=(0, 0, 0, 255))
    glow_canvas = glow_canvas.filter(ImageFilter.GaussianBlur(30))

    glow_canvas.paste(clean_icon, (glow_spread, glow_spread), clean_icon)
    return glow_canvas

def draw_stat_pill(draw, img_canvas, x, y, icon_path, count, font):
    text = f"{count:,}"
    text_bbox = draw.textbbox((0, 0), text, font=font)
    text_w = text_bbox[2] - text_bbox[0]
    text_h = text_bbox[3] - text_bbox[1]

    icon_size = 50
    padding_x = 30
    padding_y = 20
    gap = 20

    box_w = padding_x + icon_size + gap + text_w + padding_x
    box_h = text_h + (padding_y * 2)
    if box_h < icon_size + 20: box_h = icon_size + 20

    x0, y0 = x, y
    x1, y1 = x + box_w, y + box_h

    draw.rounded_rectangle([(x0, y0), (x1, y1)], radius=30, fill=(20, 20, 25, 200))

    # Load Icon
    try:
        icon = Image.open(icon_path).convert("RGBA")
        icon = icon.resize((icon_size, icon_size), Image.Resampling.LANCZOS)
        icon_y = int(y0 + (box_h - icon_size)/2)
        img_canvas.paste(icon, (int(x0 + padding_x), icon_y), icon)
    except Exception as e:
        print(f"Icon error ({icon_path}): {e}")
        draw.rectangle([(x0+padding_x, y0+padding_y), (x0+padding_x+icon_size, y0+padding_y+icon_size)], fill=(100,100,100))

    text_x = x0 + padding_x + icon_size + gap
    # MOVED UP: Originally -6, now -16 to shift text up 10px relative to box center
    text_y = y0 + (box_h - text_h)/2 - 16
    draw.text((text_x, text_y), text, font=font, fill=(255, 255, 255))

    return box_w

def generate_glowing_confetti(width, height, intensity):
    source_layer = Image.new('RGBA', (width, height), (0,0,0,0))
    draw = ImageDraw.Draw(source_layer)
    if intensity == 0: return source_layer
    colors = [(48, 178, 123), (160, 32, 240), (255, 215, 0), (50, 50, 60)]
    count = int(intensity * 15)
    center_x, center_y = width // 2, height // 2
    safe_radius = 500
    for _ in range(count):
        x = random.randint(0, width)
        y = random.randint(0, height)
        if math.sqrt((x - center_x)**2 + (y - center_y)**2) > safe_radius:
            size = random.randint(8, 20)
            color = random.choice(colors)
            draw.rectangle([x, y, x+size, y+size], fill=color + (255,))

    bloom_wide = source_layer.filter(ImageFilter.GaussianBlur(30))
    bloom_wide = ImageEnhance.Brightness(bloom_wide).enhance(0.4)
    bloom_mid = source_layer.filter(ImageFilter.GaussianBlur(10))
    bloom_mid = ImageEnhance.Brightness(bloom_mid).enhance(0.7)
    return ImageChops.add(ImageChops.add(bloom_wide, bloom_mid), source_layer)

def create_background(width, height):
    base_color = (18, 18, 24)
    img = Image.new('RGB', (width, height), base_color)
    black_layer = Image.new('RGBA', (width, height), (0,0,0,255))
    mask = Image.new('L', (width, height), 0)
    m_draw = ImageDraw.Draw(mask)
    margin_x, margin_y = 350, 200
    m_draw.rectangle([(margin_x, margin_y), (width - margin_x, height - margin_y)], fill=255)
    mask = mask.filter(ImageFilter.GaussianBlur(180))
    img.paste(black_layer, (0,0), ImageOps.invert(mask))
    return img

def draw_glowing_divider(img, x, y_start, y_end):
    overlay = Image.new('RGBA', img.size, (0,0,0,0))
    draw = ImageDraw.Draw(overlay)
    draw.line([(x, y_start), (x, y_end)], fill=(0,0,0,255), width=20)
    overlay = overlay.filter(ImageFilter.GaussianBlur(15))
    draw_sharp = ImageDraw.Draw(overlay)
    draw_sharp.line([(x, y_start), (x, y_end)], fill=(255, 255, 255, 40), width=3)
    img.paste(overlay, (0, 0), overlay)

def post_to_discord(image_path):
    print("Posting to Discord...")

    links = f"[<:modrinth:1111> Modrinth]({MODRINTH_URL}) • [<:curseforge:2222> CurseForge]({CURSEFORGE_URL}) • [Github]({SOURCE_URL})"
    content = f"**{MOD_NAME} {VERSION}** is now available!\n{links}"

    with open(image_path, 'rb') as f:
        payload = {"content": content}
        requests.post(WEBHOOK_URL, data={'payload_json': str(payload).replace("'", '"')}, files={'file': f})

# --- MAIN GENERATION ---

def generate_image(modrinth_dl, curse_dl):
    print("Generating Final Release Image...")

    img = create_background(IMG_WIDTH, IMG_HEIGHT)
    confetti_layer = generate_glowing_confetti(IMG_WIDTH, IMG_HEIGHT, HYPE_LEVEL)
    img.paste(confetti_layer, (0,0), confetti_layer)
    draw = ImageDraw.Draw(img)

    parsed_changelog = parse_commits(RAW_COMMITS)

    try:
        font_path = "assets/font.ttf"
        font_title = ImageFont.truetype(font_path, 110)
        font_stat_num = ImageFont.truetype(font_path, 50)
        font_version = ImageFont.truetype(font_path, 50)
        font_header = ImageFont.truetype(font_path, 80)
    except:
        font_title = ImageFont.load_default()
        font_stat_num = ImageFont.load_default()
        font_version = ImageFont.load_default()
        font_header = ImageFont.load_default()

    # --- LEFT PANEL ---
    c_left = PANEL_WIDTH // 2
    icon_comp = make_rounded_icon_with_glow("assets/icon.png", 400, radius=60)
    iw, ih = icon_comp.size
    icon_y = 130
    img.paste(icon_comp, (c_left - iw//2, icon_y), icon_comp)

    text_y = icon_y + ih - 30
    title_text = MOD_NAME
    bbox = draw.textbbox((0,0), title_text, font=font_title)
    w = bbox[2] - bbox[0]
    draw.text((c_left - w/2, text_y), title_text, font=font_title, fill=(255, 255, 255))

    text_y += 130
    v_text = f"Release {VERSION}"
    bbox = draw.textbbox((0,0), v_text, font=font_version)
    w = bbox[2] - bbox[0]
    draw.text((c_left - w/2, text_y), v_text, font=font_version, fill=(150, 255, 150))

    text_y += 120

    # Stats Pills
    gap = 40
    dummy_draw = ImageDraw.Draw(Image.new("RGBA", (1,1)))

    mr_text = f"{modrinth_dl:,}"
    mr_bbox = dummy_draw.textbbox((0,0), mr_text, font=font_stat_num)
    mr_w = (mr_bbox[2]-mr_bbox[0]) + 50 + 30 + 30 + 20

    cf_text = f"{curse_dl:,}"
    cf_bbox = dummy_draw.textbbox((0,0), cf_text, font=font_stat_num)
    cf_w = (cf_bbox[2]-cf_bbox[0]) + 50 + 30 + 30 + 20

    total_w = mr_w + gap + cf_w
    start_x = c_left - (total_w / 2)

    draw_stat_pill(draw, img, start_x, text_y, "assets/modrinth.ico", modrinth_dl, font_stat_num)
    draw_stat_pill(draw, img, start_x + mr_w + gap, text_y, "assets/curseforge.ico", curse_dl, font_stat_num)

    # --- MIDDLE DIVIDER ---
    draw_glowing_divider(img, PANEL_WIDTH, 150, IMG_HEIGHT - 150)

    # --- RIGHT PANEL ---
    x_right = PANEL_WIDTH + 100
    y_right = 240

    draw.text((x_right, y_right), "NEW FEATURES", font=font_header, fill=(200, 200, 220))
    y_right += 120

    text_box_width = IMG_WIDTH - x_right - 80
    text_box_height = IMG_HEIGHT - y_right - 80

    final_font, wrapped_groups, total_h, line_height = fit_text_to_box(
        draw, parsed_changelog, text_box_width, text_box_height, start_font_size=55
    )

    current_y = y_right
    for group in wrapped_groups:
        draw.text((x_right, current_y), "•", font=final_font, fill=(100, 100, 100))
        for i, line in enumerate(group):
            draw.text((x_right + 40, current_y), line, font=final_font, fill=(240, 240, 240))
            current_y += line_height
        current_y += int(line_height * 0.5)

    output_path = "release_image_final.jpg"
    img.convert("RGB").save(output_path, "JPEG", quality=95)
    print(f"Image saved to {output_path}")
    return output_path

if __name__ == "__main__":
    m_stats, c_stats = fetch_stats()
    image_file = generate_image(m_stats, c_stats)

    # Uncomment to enable posting
    post_to_discord(image_file)